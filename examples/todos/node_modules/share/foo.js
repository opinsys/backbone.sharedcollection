(function() {
  var Manager, genTests, makePassPart, newDbId, newDocName, testCase, types;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __slice = Array.prototype.slice;
  testCase = require('nodeunit').testCase;
  makePassPart = require('./helpers').makePassPart;
  Manager = require('../src/server/db/manager');
  types = require('../src/types');
  newDocName = (function() {
    var num;
    num = 0;
    return function() {
      return "doc" + (num++);
    };
  })();
  newDbId = (function() {
    var num;
    num = 0;
    return function() {
      return "db" + (num++);
    };
  })();
  genTests = function(async) {
    return testCase({
      setUp: function(callback) {
        var db, functionName, functions, id, thisdb, _i, _j, _len, _len2;
        this.name = newDocName();
        this.db = {};
        functions = ['getOps', 'create', 'delete', 'writeOp', 'writeSnapshot', 'getSnapshot', 'getVersion', 'close'];
        id = newDbId();
        for (_i = 0, _len = functions.length; _i < _len; _i++) {
          functionName = functions[_i];
          this.db[functionName] = (function(functionName) {
            return function() {
              throw new Error("Unexpected call to " + functionName + " in " + id);
            };
          })(functionName);
        }
        this.setDb = __bind(function(db) {
          return this.man = new Manager(db, {
            reapTime: 10,
            numCachedOps: 2,
            opsBeforeCommit: 2
          });
        }, this);
        if (async) {
          thisdb = this.db;
          db = {};
          for (_j = 0, _len2 = functions.length; _j < _len2; _j++) {
            functionName = functions[_j];
            db[functionName] = (function(functionName) {
              return function() {
                var args, error;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                error = new Error;
                return setTimeout((function() {
                  try {
                    return thisdb[functionName].apply(null, args);
                  } catch (e) {
                    console.warn(error.stack);
                    throw e;
                  }
                }), 50);
              };
            })(functionName);
          }
          this.setDb(db);
        } else {
          this.setDb(this.db);
        }
        console.warn("db id " + id);
        return callback();
      },
      'create creates in the DB': function(test) {
        this.db.create = __bind(function(docName, data, callback) {
          test.strictEqual(docName, this.name);
          test.deepEqual(data, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
          return callback(null, {
            'metablag': true
          });
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, function(error) {
          test.equal(error, null);
          test.expect(3);
          return test.done();
        });
      },
      'Errors in create are passed to the caller': function(test) {
        this.db.create = __bind(function(docName, data, callback) {
          return callback('invalid tubes!');
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, function(error) {
          test.strictEqual(error, 'invalid tubes!');
          return test.done();
        });
      },
      'If the database is null, create still works': function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, function(error) {
          test.equal(error, null);
          return test.done();
        });
      },
      'create caches the document data': function(test) {
        this.db.create = __bind(function(docName, data, callback) {
          return callback();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.getSnapshot(this.name, __bind(function(error, data) {
            test.deepEqual(data, {
              snapshot: {
                str: 'hi'
              },
              type: types.simple,
              meta: {},
              v: 0
            });
            return this.man.getVersion(this.name, function(error, version) {
              test.strictEqual(version, 0);
              return test.done();
            });
          }, this));
        }, this));
      },
      'create caches the document data even if the db is null': function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.getSnapshot(this.name, function(error, data) {
            test.deepEqual(data, {
              snapshot: {
                str: 'hi'
              },
              type: types.simple,
              meta: {},
              v: 0
            });
            return test.done();
          });
        }, this));
      },
      "if there is an error in db.create, the document isn't cached": function(test) {
        this.db.create = __bind(function(docName, data, callback) {
          return callback('invalid tubes!');
        }, this);
        this.db.getSnapshot = __bind(function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        }, this);
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function() {
          return this.man.getSnapshot(this.name, function(error, data) {
            test.equal(error, null);
            test.deepEqual(data, {
              snapshot: {
                str: 'hi'
              },
              type: types.simple,
              meta: {},
              v: 0
            });
            return test.done();
          });
        }, this));
      },
      "if create is passed a type literal, the database is given the type name": function(test) {
        this.db.create = __bind(function(docName, data, callback) {
          test.deepEqual(data, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
          return callback();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: types.simple,
          meta: {},
          v: 0
        }, function(error) {
          test.expect(1);
          return test.done();
        });
      },
      "If create is given a type name that doesn't exist, it sends an error": function(test) {
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'does not exist',
          meta: {},
          v: 0
        }, function(error) {
          test.strictEqual(error, 'Type not found');
          return test.done();
        });
      },
      "getSnapshot() data is passed from the database": function(test) {
        this.db.getSnapshot = function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        return this.man.getSnapshot(this.name, function(error, data) {
          test.equal(error, null);
          test.deepEqual(data, {
            snapshot: {
              str: 'hi'
            },
            type: types.simple,
            meta: {},
            v: 0
          });
          return test.done();
        });
      },
      "getSnapshot() propogates errors from the database": function(test) {
        this.db.getSnapshot = function(docName, callback) {
          return callback('invalid tubes!');
        };
        return this.man.getSnapshot(this.name, function(error, data) {
          test.strictEqual(error, 'invalid tubes!');
          test.equal(data, null);
          return test.done();
        });
      },
      "If getSnapshot() returns a type name that doesn't exist, we return an error": function(test) {
        this.db.getSnapshot = function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'does not exist',
            meta: {},
            v: 0
          });
        };
        return this.man.getSnapshot(this.name, function(error, data) {
          test.strictEqual(error, 'Type not found');
          return test.done();
        });
      },
      "If there is an error with getSnapshot(), the document isn't cached": function(test) {
        this.db.getSnapshot = __bind(function(docName, callback) {
          this.db.getSnapshot = function() {
            return test.done();
          };
          return callback('invalid tubes!');
        }, this);
        return this.man.getSnapshot(this.name, __bind(function() {
          return this.man.getSnapshot(this.name, function() {});
        }, this));
      },
      "getSnapshot() data is cached": function(test) {
        this.db.getSnapshot = __bind(function(docName, callback) {
          this.db.getSnapshot = function() {
            throw new Error('getSnapshot data should have been cached');
          };
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        }, this);
        this.db.getOps = __bind(function(docName, start, end, callback) {
          this.db.getOps = function() {
            throw new Error('getSnapshot data should have been cached');
          };
          return callback(null, []);
        }, this);
        return this.man.getSnapshot(this.name, __bind(function() {
          return this.man.getSnapshot(this.name, function() {
            return test.done();
          });
        }, this));
      },
      "if the db is null and there's no cached data, getSnapshot() raises an error": function(test) {
        this.setDb(null);
        return this.man.getSnapshot(this.name, function(error, data) {
          test.strictEqual(error, 'Document does not exist');
          test.equal(data, null);
          return test.done();
        });
      },
      'Multiple simultaneous calls to getSnapshot and getVersion only result in one getSnapshot call on the database': function(test) {
        var check, passPart, __ignored, _results;
        this.db.getSnapshot = __bind(function(docName, callback) {
          this.db.getSnapshot = function() {
            throw new Error('getSnapshot should only be called once');
          };
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 100
          });
        }, this);
        this.db.getOps = __bind(function(docName, start, end, callback) {
          this.db.getOps = function() {
            throw new Error('getOps should only be called once');
          };
          return callback(null, []);
        }, this);
        passPart = makePassPart(test, 10);
        check = function(expectedData) {
          return function(error, data) {
            test.deepEqual(data, expectedData);
            return passPart();
          };
        };
        for (__ignored = 1; __ignored <= 5; __ignored++) {
          this.man.getSnapshot(this.name, check({
            snapshot: {
              str: 'hi'
            },
            type: types.simple,
            meta: {},
            v: 100
          }));
        }
        _results = [];
        for (__ignored = 1; __ignored <= 5; __ignored++) {
          _results.push(this.man.getVersion(this.name, check(100)));
        }
        return _results;
      },
      'if create is passed a type literal and theres no database, getSnapshot still returns type literals': function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: types.simple,
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.getSnapshot(this.name, function(error, data) {
            test.deepEqual(data, {
              snapshot: {
                str: 'hi'
              },
              type: types.simple,
              meta: {},
              v: 0
            });
            return test.done();
          });
        }, this));
      },
      'getSnapshot catches up the document with all recent ops': function(test) {
        this.db.getSnapshot = __bind(function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 1
          });
        }, this);
        this.db.getOps = __bind(function(docName, start, end, callback) {
          test.strictEqual(docName, this.name);
          test.strictEqual(start, 1);
          test.strictEqual(end, null);
          return callback(null, [
            {
              op: {
                position: 2,
                text: ' there'
              },
              meta: {}
            }, {
              op: {
                position: 8,
                text: ' mum'
              },
              meta: {}
            }
          ]);
        }, this);
        return this.man.getSnapshot(this.name, function(error, data) {
          test.equal(error, null);
          test.deepEqual(data, {
            snapshot: {
              str: 'hi there mum'
            },
            type: types.simple,
            meta: {},
            v: 3
          });
          return test.done();
        });
      },
      'getVersion passes errors from db.getSnapshot': function(test) {
        this.db.getSnapshot = function(docName, callback) {
          return callback('Invalid weboplex');
        };
        return this.man.getVersion(this.name, function(error, version) {
          test.strictEqual(error, 'Invalid weboplex');
          test.equal(version, null);
          return test.done();
        });
      },
      'getVersion works correctly even if the db snapshot is old': function(test) {
        this.db.getSnapshot = __bind(function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 1
          });
        }, this);
        this.db.getOps = __bind(function(docName, start, end, callback) {
          test.strictEqual(docName, this.name);
          test.strictEqual(start, 1);
          test.strictEqual(end, null);
          return callback(null, [
            {
              op: {
                position: 2,
                text: ' there'
              },
              meta: {}
            }, {
              op: {
                position: 8,
                text: ' mum'
              },
              meta: {}
            }
          ]);
        }, this);
        return this.man.getVersion(this.name, function(error, version) {
          test.equal(error, null);
          test.deepEqual(version, 3);
          return test.done();
        });
      },
      "db.delete is called on delete": function(test) {
        this.db["delete"] = __bind(function(docName, dbMeta, callback) {
          test.strictEqual(docName, this.name);
          test.equal(dbMeta, null);
          return callback();
        }, this);
        return this.man["delete"](this.name, function(error) {
          test.equal(error, null);
          return test.done();
        });
      },
      "delete errors are propogated": function(test) {
        this.db["delete"] = function(docName, dbMeta, callback) {
          return callback("invalid tubes!");
        };
        return this.man["delete"](this.name, function(error) {
          test.strictEqual(error, "invalid tubes!");
          return test.done();
        });
      },
      'Deleting a nonexistant document with no database raises an error': function(test) {
        this.setDb(null);
        return this.man["delete"](this.name, function(error) {
          test.strictEqual(error, 'Document does not exist');
          return test.done();
        });
      },
      "delete removes any cached data": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db["delete"] = function(docName, dbMeta, callback) {
          return callback();
        };
        this.db.getSnapshot = function() {
          return test.done();
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man["delete"](this.name, __bind(function(error) {
            return this.man.getSnapshot(this.name, function() {});
          }, this));
        }, this));
      },
      "delete removes any cached data if db is null": function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man["delete"](this.name, __bind(function(error) {
            test.equal(error, null);
            return this.man.getSnapshot(this.name, function(error, data) {
              test.strictEqual(error, 'Document does not exist');
              test.equal(data, null);
              return test.done();
            });
          }, this));
        }, this));
      },
      "dbMeta is passed from create() to delete": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback(null, {
            db: 'meta'
          });
        };
        this.db["delete"] = function(docName, dbMeta, callback) {
          test.deepEqual(dbMeta, {
            db: 'meta'
          });
          return callback();
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man["delete"](this.name, __bind(function(error) {
            return test.done();
          }, this));
        }, this));
      },
      'append calls writeOp': function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = __bind(function(docName, opData, callback) {
          test.strictEqual(docName, this.name);
          test.deepEqual(opData, {
            v: 0,
            op: [123],
            meta: {}
          });
          return callback();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            test.equal(error, null);
            test.expect(3);
            return test.done();
          }, this));
        }, this));
      },
      'append propogates errors from writeOp': function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback('intersplat');
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, function(error) {
            test.strictEqual(error, 'intersplat');
            return test.done();
          });
        }, this));
      },
      'append on uncached data works': function(test) {
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.getSnapshot = function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        return this.man.append(this.name, {
          v: 0,
          op: [123],
          meta: {}
        }, {
          snapshot: {
            str: 'bar'
          },
          type: 'simple',
          meta: {},
          v: 1
        }, __bind(function(error) {
          return test.done();
        }, this));
      },
      "Despite appending with a string type, getSnapshot makes the type an object": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = function(docName, data, dbMeta, callback) {
          return callback();
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.getSnapshot(this.name, function(error, data) {
              test.deepEqual(data, {
                snapshot: {
                  str: 'hi'
                },
                type: types.simple,
                meta: {},
                v: 1
              });
              return test.done();
            });
          }, this));
        }, this));
      },
      "writeSnapshot is called after the specified number of ops are appended": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
          test.strictEqual(docName, this.name);
          test.deepEqual(data, {
            snapshot: {
              str: 'data3'
            },
            type: types.simple,
            meta: {},
            v: 2
          });
          test.equal(dbMeta, null);
          callback();
          return test.done();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              test.equal(error, null);
              return test.expect(4);
            }, this));
          }, this));
        }, this));
      },
      "writeSnapshot is not called again for a little while afterwards": function(test) {
        var doc, op;
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
          test.strictEqual(data.v, 2);
          this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
            test.strictEqual(data.v, 4);
            this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
              throw new Error('writeSnapshot called too many times');
            }, this);
            return callback();
          }, this);
          return callback();
        }, this);
        op = function(v) {
          return {
            v: v,
            op: [123],
            meta: {}
          };
        };
        doc = function(v) {
          return {
            v: v,
            snapshot: {
              str: "doc" + v
            },
            type: 'simple',
            meta: {}
          };
        };
        return this.man.create(this.name, doc(0), __bind(function(error) {
          return this.man.append(this.name, op(0), doc(1), __bind(function(error) {
            return this.man.append(this.name, op(1), doc(2), __bind(function(error) {
              return process.nextTick(__bind(function() {
                return this.man.append(this.name, op(2), doc(3), __bind(function(error) {
                  return process.nextTick(__bind(function() {
                    return this.man.append(this.name, op(3), doc(4), __bind(function(error) {
                      return process.nextTick(__bind(function() {
                        return this.man.append(this.name, op(4), doc(5), __bind(function(error) {
                          return test.done();
                        }, this));
                      }, this));
                    }, this));
                  }, this));
                }, this));
              }, this));
            }, this));
          }, this));
        }, this));
      },
      "dbMeta is passed from create() to writeSnapshot": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback(null, {
            db: 'meta'
          });
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
          test.deepEqual(dbMeta, {
            db: 'meta'
          });
          return test.done();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {}, this));
          }, this));
        }, this));
      },
      "With no database, writing a few ops doesn't make the man freik out or anything": function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            test.equal(error, null);
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              test.equal(error, null);
              return this.man.append(this.name, {
                v: 2,
                op: [123],
                meta: {}
              }, {
                snapshot: {
                  str: 'data4'
                },
                type: 'simple',
                meta: {},
                v: 3
              }, __bind(function(error) {
                test.equal(error, null);
                return test.done();
              }, this));
            }, this));
          }, this));
        }, this));
      },
      'With no listeners, documents are reaped': function(test) {
        var called;
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        called = false;
        this.db.getSnapshot = function(docName, callback) {
          called = true;
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return setTimeout(__bind(function() {
            return this.man.getSnapshot(this.name, function(error, data) {
              test.deepEqual(data, {
                snapshot: {
                  str: 'hi'
                },
                type: types.simple,
                meta: {},
                v: 0
              });
              test.strictEqual(called, true);
              return test.done();
            });
          }, this), 15);
        }, this));
      },
      'With listening clients, documents are not reaped': function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.getSnapshot = function(docName, callback) {
          throw new Error('The object should still be cached');
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          this.man.docOpened(this.name, {
            id: 'abc123'
          });
          return setTimeout(__bind(function() {
            return this.man.getSnapshot(this.name, function(error, data) {
              test.deepEqual(data, {
                snapshot: {
                  str: 'hi'
                },
                type: types.simple,
                meta: {},
                v: 0
              });
              return test.done();
            });
          }, this), 15);
        }, this));
      },
      'When a client connects then disconnects, documents are reaped again': function(test) {
        var called;
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        called = false;
        this.db.getSnapshot = function(docName, callback) {
          called = true;
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          var client;
          client = {
            id: 'abc123'
          };
          return this.man.docOpened(this.name, client, __bind(function(error) {
            test.equal(error, null);
            this.man.docClosed(this.name, client);
            return setTimeout(__bind(function() {
              return this.man.getSnapshot(this.name, function(error, data) {
                test.deepEqual(data, {
                  snapshot: {
                    str: 'hi'
                  },
                  type: types.simple,
                  meta: {},
                  v: 0
                });
                test.strictEqual(called, true);
                return test.done();
              });
            }, this), 15);
          }, this));
        }, this));
      },
      'When there is no database, documents are not reaped': function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return setTimeout(__bind(function() {
            return this.man.getSnapshot(this.name, function(error, data) {
              test.deepEqual(data, {
                snapshot: {
                  str: 'hi'
                },
                type: types.simple,
                meta: {},
                v: 0
              });
              return test.done();
            });
          }, this), 15);
        }, this));
      },
      'Submitted ops are cached': function(test) {
        var passPart;
        passPart = makePassPart(test, 6);
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = function(docName, data, dbMeta, callback) {
          return callback();
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              this.man.getOps(this.name, 0, 2, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, [
                  {
                    v: 0,
                    op: [123],
                    meta: {}
                  }, {
                    v: 1,
                    op: [123],
                    meta: {}
                  }
                ]);
                return passPart();
              }, this));
              this.man.getOps(this.name, 1, 2, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, [
                  {
                    v: 1,
                    op: [123],
                    meta: {}
                  }
                ]);
                return passPart();
              }, this));
              this.man.getOps(this.name, 0, 1, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, [
                  {
                    v: 0,
                    op: [123],
                    meta: {}
                  }
                ]);
                return passPart();
              }, this));
              this.man.getOps(this.name, 0, 0, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, []);
                return passPart();
              }, this));
              this.man.getOps(this.name, 1, 1, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, []);
                return passPart();
              }, this));
              return this.man.getOps(this.name, 2, 2, __bind(function(error, ops) {
                test.equal(error, null);
                test.deepEqual(ops, []);
                return passPart();
              }, this));
            }, this));
          }, this));
        }, this));
      },
      "Ops stop being cached once we have too many of them": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = function(docName, data, dbMeta, callback) {
          return callback();
        };
        this.db.getOps = __bind(function(docName, start, end, callback) {
          test.strictEqual(start, 0);
          test.strictEqual(end, 0);
          test.strictEqual(docName, this.name);
          return callback(null, [
            {
              op: [123],
              meta: {}
            }
          ]);
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              return this.man.append(this.name, {
                v: 2,
                op: [123],
                meta: {}
              }, {
                snapshot: {
                  str: 'data4'
                },
                type: 'simple',
                meta: {},
                v: 3
              }, __bind(function(error) {
                return this.man.getOps(this.name, 0, 0, function(error, ops) {
                  test.equal(error, null);
                  test.deepEqual(ops, [
                    {
                      v: 0,
                      op: [123],
                      meta: {}
                    }
                  ]);
                  test.expect(5);
                  return test.done();
                });
              }, this));
            }, this));
          }, this));
        }, this));
      },
      "Calling getOps() directly when there's no cached data calls the database": function(test) {
        this.db.getOps = __bind(function(docName, start, end, callback) {
          test.strictEqual(start, 100);
          test.strictEqual(end, 102);
          test.strictEqual(docName, this.name);
          return callback(null, [
            {
              op: [100],
              meta: {}
            }, {
              op: [101],
              meta: {}
            }, {
              op: [102],
              meta: {}
            }
          ]);
        }, this);
        return this.man.getOps(this.name, 100, 102, function(error, ops) {
          test.equal(error, null);
          test.deepEqual(ops, [
            {
              v: 100,
              op: [100],
              meta: {}
            }, {
              v: 101,
              op: [101],
              meta: {}
            }, {
              v: 102,
              op: [102],
              meta: {}
            }
          ]);
          return test.done();
        });
      },
      'getOps passes errors to the callback': function(test) {
        this.db.getOps = function(docName, start, end, callback) {
          return callback('blargh death');
        };
        return this.man.getOps(this.name, 100, 102, function(error, ops) {
          test.strictEqual(error, 'blargh death');
          test.equal(ops, null);
          return test.done();
        });
      },
      "getOps() with no db and no cached data returns an error": function(test) {
        this.setDb(null);
        return this.man.getOps(this.name, 100, 102, function(error, ops) {
          test.strictEqual(error, 'Document does not exist');
          return test.done();
        });
      },
      "getOps() with no db and cached data can return the cached data": function(test) {
        var passPart;
        passPart = makePassPart(test, 4);
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              return this.man.append(this.name, {
                v: 2,
                op: [123],
                meta: {}
              }, {
                snapshot: {
                  str: 'data4'
                },
                type: 'simple',
                meta: {},
                v: 3
              }, __bind(function(error) {
                this.man.getOps(this.name, 0, 3, __bind(function(error, data) {
                  test.equal(error, null);
                  test.deepEqual(data, [
                    {
                      v: 0,
                      op: [123],
                      meta: {}
                    }, {
                      v: 1,
                      op: [123],
                      meta: {}
                    }, {
                      v: 2,
                      op: [123],
                      meta: {}
                    }
                  ]);
                  return passPart();
                }, this));
                this.man.getOps(this.name, 0, 2, __bind(function(error, data) {
                  test.equal(error, null);
                  test.deepEqual(data, [
                    {
                      v: 0,
                      op: [123],
                      meta: {}
                    }, {
                      v: 1,
                      op: [123],
                      meta: {}
                    }
                  ]);
                  return passPart();
                }, this));
                this.man.getOps(this.name, 1, 3, __bind(function(error, data) {
                  test.equal(error, null);
                  test.deepEqual(data, [
                    {
                      v: 1,
                      op: [123],
                      meta: {}
                    }, {
                      v: 2,
                      op: [123],
                      meta: {}
                    }
                  ]);
                  return passPart();
                }, this));
                return this.man.getOps(this.name, 2, 3, function(error, data) {
                  test.equal(error, null);
                  test.deepEqual(data, [
                    {
                      v: 2,
                      op: [123],
                      meta: {}
                    }
                  ]);
                  return passPart();
                });
              }, this));
            }, this));
          }, this));
        }, this));
      },
      "getOps sends an error if the document doesn't exist with no db": function(test) {
        this.setDb(null);
        return this.man.getOps(this.name, 0, null, function(error, data) {
          test.strictEqual(error, 'Document does not exist');
          test.equal(data, null);
          return test.done();
        });
      },
      'flush with no documents open does nothing': function(test) {
        return this.man.flush(function() {
          return test.done();
        });
      },
      "flush doesn't need a callback": function(test) {
        this.man.flush();
        return test.done();
      },
      'flush with a document thats just been created (and hence is in the DB) does nothing': function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        return this.man.create(this.name, {
          snapshot: {
            str: 'hi'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.flush(function() {
            return test.done();
          });
        }, this));
      },
      "flush with a document that hasn't been edited does nothing": function(test) {
        this.db.getSnapshot = function(docName, callback) {
          return callback(null, {
            snapshot: {
              str: 'hi'
            },
            type: 'simple',
            meta: {},
            v: 0
          });
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        return this.man.getSnapshot(this.name, __bind(function(error, data) {
          return this.man.flush(function() {
            return test.done();
          });
        }, this));
      },
      "flush calls getSnapshot on open documents": function(test) {
        var snapshotWritten;
        this.db.create = function(docName, data, callback) {
          return callback(null, {
            db: 'meta'
          });
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.getOps = function(docName, start, end, callback) {
          return callback(null, []);
        };
        snapshotWritten = false;
        this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
          test.strictEqual(docName, this.name);
          test.deepEqual(data, {
            snapshot: {
              str: 'data2'
            },
            type: types.simple,
            meta: {},
            v: 1
          });
          test.deepEqual(dbMeta, {
            db: 'meta'
          });
          snapshotWritten = true;
          return callback();
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.flush(function() {
              test.strictEqual(snapshotWritten, true);
              return test.done();
            });
          }, this));
        }, this));
      },
      "flushing a document which has already been flushed does nothing": function(test) {
        this.db.create = function(docName, data, callback) {
          return callback();
        };
        this.db.writeOp = function(docName, opData, callback) {
          return callback();
        };
        this.db.writeSnapshot = __bind(function(docName, data, dbMeta, callback) {
          this.db.writeSnapshot = function(docName, data, dbMeta, callback) {
            throw new Error("Snapshot already saved");
          };
          callback();
          return this.man.flush(function() {
            return test.done();
          });
        }, this);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.append(this.name, {
              v: 1,
              op: [123],
              meta: {}
            }, {
              snapshot: {
                str: 'data3'
              },
              type: 'simple',
              meta: {},
              v: 2
            }, __bind(function(error) {
              return test.equal(error, null);
            }, this));
          }, this));
        }, this));
      },
      "flush with no database does nothing": function(test) {
        this.setDb(null);
        return this.man.create(this.name, {
          snapshot: {
            str: 'data1'
          },
          type: 'simple',
          meta: {},
          v: 0
        }, __bind(function(error) {
          return this.man.append(this.name, {
            v: 0,
            op: [123],
            meta: {}
          }, {
            snapshot: {
              str: 'data2'
            },
            type: 'simple',
            meta: {},
            v: 1
          }, __bind(function(error) {
            return this.man.flush(function() {
              return test.done();
            });
          }, this));
        }, this));
      }
    });
  };
  exports['sync'] = genTests(false);
  exports['async'] = genTests(true);
}).call(this);
